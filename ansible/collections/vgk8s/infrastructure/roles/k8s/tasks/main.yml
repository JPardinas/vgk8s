---
# tasks file for k8s
- name: Disable swap
  ansible.builtin.command: swapoff -a
  become: true

- name: Disable swap permanently, persist across reboots
  ansible.builtin.replace:
    path: /etc/fstab
    regexp: '^([^#].*?\sswap\s+sw\s+.*)$'
    replace: '# \1'
  become: true

- name: Load overlay module
  ansible.builtin.command: modprobe overlay
  become: true

- name: Load br_netfilter module
  ansible.builtin.command: modprobe br_netfilter
  become: true

- name: Enable ip forwarding
  become: true
  ansible.builtin.lineinfile:
    path: /etc/sysctl.d/kubernetes.conf
    line: "{{ item }}"
    create: yes
    owner: root
    group: root
    mode: '0644'
  with_items:
    - net.bridge.bridge-nf-call-ip6tables = 1
    - net.bridge.bridge-nf-call-iptables = 1
    - net.ipv4.ip_forward = 1

- name: Command load new kernel parameters
  become: true
  ansible.builtin.command: "sysctl --system"

- name: Check if containerd service is running
  ansible.builtin.systemd:
    name: containerd
    state: started
  register: containerd_service_status
  ignore_errors: true

- name: Download containerd from https://github.com/containerd/containerd/releases/download/v1.7.10/containerd-1.7.10-linux-amd64.tar.gz
  ansible.builtin.get_url:
    url: https://github.com/containerd/containerd/releases/download/v1.7.10/containerd-1.7.10-linux-amd64.tar.gz
    dest: /home/{{ ansible_user }}/containerd-1.7.10-linux-amd64.tar.gz
    mode: '0644'
  when: containerd_service_status.failed

- name: Extract containerd tarball
  ansible.builtin.unarchive:
    src: /home/{{ ansible_user }}/containerd-1.7.10-linux-amd64.tar.gz
    dest: /home/{{ ansible_user }}
    remote_src: yes
    owner: "{{ ansible_user }}"
    group: "{{ ansible_user }}"
    mode: '0755'
  when: containerd_service_status.failed

- name: Move containerd binaries to /usr/bin
  ansible.builtin.shell: "mv /home/{{ ansible_user }}/bin/* /usr/local/bin/"
  become: true
  when: containerd_service_status.failed

- name: Remove containerd tarball
  ansible.builtin.file:
    path: /home/{{ ansible_user }}/containerd-1.7.10-linux-amd64.tar.gz
    state: absent
  become: true
  when: containerd_service_status.failed

- name: Remove bin directory
  ansible.builtin.file:
    path: /home/{{ ansible_user }}/bin
    state: absent
  when: containerd_service_status.failed

- name: Download containerd systemd unit file
  ansible.builtin.get_url:
    url: https://raw.githubusercontent.com/containerd/containerd/main/containerd.service
    dest: /etc/systemd/system/containerd.service
    mode: '0644'
  become: true
  when: containerd_service_status.failed

- name: Reload systemd daemon
  ansible.builtin.command: "systemctl daemon-reload"
  become: true
  when: containerd_service_status.failed

- name: Enable containerd
  ansible.builtin.service:
    name: containerd
    daemon_reload: yes
    state: started
    enabled: yes
  become: true
  when: containerd_service_status.failed

- name: Configure containerd
  ansible.builtin.shell: |
    containerd config default > /home/{{ ansible_user }}/containerd-config.toml
    sudo mkdir -p /etc/containerd
    sudo mv /home/{{ ansible_user }}/containerd-config.toml /etc/containerd/config.toml
  become: true
  when: containerd_service_status.failed

- name: Set pause version to 3.9 under containerd config sandbox_image = "registry.k8s.io/pause:3.9"
  ansible.builtin.replace:
    path: /etc/containerd/config.toml
    regexp: '^(\s*sandbox_image\s*=\s*"registry.k8s.io/pause:).*$'
    replace: '\g<1>3.9"'
  become: true

- name: Enable SystemdCgroup = true in containerd
  ansible.builtin.replace:
    path: /etc/containerd/config.toml
    regexp: '^(\s*SystemdCgroup\s*=\s*false\s*)$'
    replace: 'SystemdCgroup = true'
  become: true
  when: containerd_service_status.failed

- name: Restart containerd
  ansible.builtin.service:
    name: containerd
    daemon_reload: yes
    state: restarted
  become: true
  when: containerd_service_status.failed

- name: Download runc.amd64 from https://github.com/opencontainers/runc/releases/download/v1.1.10/runc.amd64
  ansible.builtin.get_url:
    url: https://github.com/opencontainers/runc/releases/download/v1.1.10/runc.amd64
    dest: /home/{{ ansible_user }}/runc.amd64
    mode: '0755'
  when: containerd_service_status.failed

- name: install -m 755 runc.amd64 /usr/local/sbin/runc
  ansible.builtin.shell: "install -m 755 /home/{{ ansible_user }}/runc.amd64 /usr/local/sbin/runc"
  become: true
  when: containerd_service_status.failed

- name: Remove runc.amd64
  ansible.builtin.file:
    path: /home/{{ ansible_user }}/runc.amd64
    state: absent
  become: true
  when: containerd_service_status.failed

- name: Download CNI plugins from https://github.com/containernetworking/plugins/releases/download/v1.4.0/cni-plugins-linux-amd64-v1.4.0.tgz
  ansible.builtin.get_url:
    url: https://github.com/containernetworking/plugins/releases/download/v1.4.0/cni-plugins-linux-amd64-v1.4.0.tgz
    dest: /home/{{ ansible_user }}/cni-plugins-linux-amd64-v1.4.0.tgz
    mode: '0644'
  when: containerd_service_status.failed

- name: Create /opt/cni/bin directory
  ansible.builtin.file:
    path: /opt/cni/bin
    state: directory
    owner: "{{ ansible_user }}"
    group: "{{ ansible_user }}"
    mode: '0755'
  become: true
  when: containerd_service_status.failed

- name: Extract CNI plugins tarball
  ansible.builtin.unarchive:
    src: /home/{{ ansible_user }}/cni-plugins-linux-amd64-v1.4.0.tgz
    dest: /opt/cni/bin
    remote_src: yes
    owner: "{{ ansible_user }}"
    group: "{{ ansible_user }}"
    mode: '0755'
  become: true
  when: containerd_service_status.failed

- name: Remove CNI plugins tarball
  ansible.builtin.file:
    path: /home/{{ ansible_user }}/cni-plugins-linux-amd64-v1.4.0.tgz
    state: absent
  become: true
  when: containerd_service_status.failed

- name: Check if kubectl is already installed
  ansible.builtin.command:
    cmd: kubectl version --client
  register: kubectl_installed
  ignore_errors: true

- name: Install apt-transport-https, ca-certificates, curl, gnugpg
  become: true
  ansible.builtin.apt:
    name: "{{ item }}"
    state: present
    update_cache: yes
  loop:
    - apt-transport-https
    - ca-certificates
    - curl
    - gnupg
  when: kubectl_installed.failed

- name: Add Kubernetes apt-key
  become: true
  ansible.builtin.apt_key:
    url: https://pkgs.k8s.io/core:/stable:/v1.28/deb/Release.key
    state: present
    keyring: /etc/apt/trusted.gpg.d/kubernetes.gpg
  when: kubectl_installed.failed

# echo 'deb [arch=amd64 signed-by=/etc/apt/trusted.gpg.d/kubernetes.gpg] https://pkgs.k8s.io/core:/stable:/v1.28/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list > /dev/null
- name: Add Kubernetes Repository
  become: true
  ansible.builtin.apt_repository:
    repo: deb [arch=amd64 signed-by=/etc/apt/trusted.gpg.d/kubernetes.gpg] https://pkgs.k8s.io/core:/stable:/v1.28/deb/ /
    state: present
  when: kubectl_installed.failed

- name: Update apt and install kubelet, kubeadm and kubectl
  become: true
  ansible.builtin.apt:
    name: "{{ item }}"
    state: present
    update_cache: yes
  loop:
    - kubelet
    - kubeadm
    - kubectl
  when: kubectl_installed.failed

- name: Hold kubelet, kubeadm, and kubectl at the current version
  become: true
  ansible.builtin.apt:
    name: "{{ item }}"
    state: fixed
    update_cache: yes
    cache_valid_time: 3600
  loop:
    - kubelet
    - kubeadm
    - kubectl
  when: kubectl_installed.failed

- name: Check if kubeadm is already initialized
  become: true
  ansible.builtin.stat:
    path: /etc/kubernetes/admin.conf
  register: kubeadm_initialized

- name: Initialize kubeadm
  become: true
  ansible.builtin.command: "kubeadm init --pod-network-cidr=10.244.0.0/16 --apiserver-advertise-address={{ ansible_eth1.ipv4.address }}"
  when: kubeadm_initialized.stat.exists == false

# Configure kubectl
- name: Create .kube directory
  ansible.builtin.file:
    path: $HOME/.kube
    state: directory
    owner: "{{ ansible_user }}"
    group: "{{ ansible_user }}"
    mode: '0755'
  when: kubeadm_initialized.stat.exists == false

- name: Copy admin.conf to .kube directory
  become: true
  ansible.builtin.copy:
    src: /etc/kubernetes/admin.conf
    dest: /home/{{ ansible_user }}/.kube/config
    remote_src: yes
    owner: "{{ ansible_user }}"
    group: "{{ ansible_user }}"
    mode: '0600'
  when: kubeadm_initialized.stat.exists == false

- name: Copy admin.conf to /vagrant directory
  become: true
  ansible.builtin.copy:
    src: /etc/kubernetes/admin.conf
    dest: /vagrant/admin.conf
    remote_src: yes
    owner: "{{ ansible_user }}"
    group: "{{ ansible_user }}"
    mode: '0600'
  when: kubeadm_initialized.stat.exists == false

- name: Enable master node to schedule pods
  ansible.builtin.command: "kubectl taint nodes --all node-role.kubernetes.io/control-plane-"
  when: kubeadm_initialized.stat.exists == false

# Flannel CNI (finally decided for flannel because calico was causing conflicts with metallb)
- name: Create namespace kube-flannel
  ansible.builtin.command: "kubectl create namespace kube-flannel"
  when: kubeadm_initialized.stat.exists == false

- name: Label namespace kube-flannel
  ansible.builtin.command: "kubectl label --overwrite ns kube-flannel pod-security.kubernetes.io/enforce=privileged"
  when: kubeadm_initialized.stat.exists == false

- name: Add helm repo add flannel
  ansible.builtin.command: "helm repo add flannel https://flannel-io.github.io/flannel/"
  when: kubeadm_initialized.stat.exists == false

- name: helm repo update
  ansible.builtin.command: "helm repo update"
  when: kubeadm_initialized.stat.exists == false

- name: helm install flannel --set podCidr="10.244.0.0/16" --namespace kube-flannel flannel/flannel
  ansible.builtin.command: "helm install flannel --set podCidr=\"10.244.0.0/16\" --namespace kube-flannel flannel/flannel"
  when: kubeadm_initialized.stat.exists == false

# MetalLB
- name: helm repo add metallb https://metallb.github.io/metallb
  ansible.builtin.command: "helm repo add metallb https://metallb.github.io/metallb"
  when: kubeadm_initialized.stat.exists == false

- name: helm repo update
  ansible.builtin.command: "helm repo update"
  when: kubeadm_initialized.stat.exists == false

- name: Create namespace metallb-system
  ansible.builtin.command: "kubectl create namespace metallb-system"
  when: kubeadm_initialized.stat.exists == false

- name: helm install metallb metallb/metallb --namespace metallb-system
  ansible.builtin.command: "helm install metallb metallb/metallb --namespace metallb-system"
  when: kubeadm_initialized.stat.exists == false

# apiVersion: metallb.io/v1beta1
# kind: IPAddressPool
# metadata:
#   name: default
#   namespace: metallb-system
# spec:
#   addresses:
#   - 192.168.56.100-192.168.56.100
- name: Create metallb IP address pool (using echo) # TODO: improve this
  ansible.builtin.shell: "echo 'apiVersion: metallb.io/v1beta1\nkind: IPAddressPool\nmetadata:\n  name: default\n  namespace: metallb-system\nspec:\n  addresses:\n  - {{ ansible_eth1.ipv4.address }}-{{ ansible_eth1.ipv4.address }}' > /home/{{ ansible_user }}/metallb-ipaddresspool.yaml"
  when: kubeadm_initialized.stat.exists == false
  
- name: Create metallb IP address pool
  ansible.builtin.command: "kubectl apply -f /home/{{ ansible_user }}/metallb-ipaddresspool.yaml"
  when: kubeadm_initialized.stat.exists == false



# Setup NFS Server
- name: Install NFS Server
  become: true
  ansible.builtin.apt:
    name: "{{ item }}"
    state: present
    update_cache: yes
  loop:
    - nfs-kernel-server

- name: Create NFS directory
  become: true
  ansible.builtin.file:
    path: /mnt/nfs_share
    state: directory
    owner: "{{ ansible_user }}"
    group: "{{ ansible_user }}"
    mode: '0755'

- name: Add NFS directory to exports
  become: true
  ansible.builtin.lineinfile:
    path: /etc/exports
    line: "/mnt/nfs_share *(rw,sync,no_subtree_check,no_root_squash)"
    create: yes
    owner: root
    group: root
    mode: '0644'
  
- name: Restart NFS Server
  become: true
  ansible.builtin.service:
    name: nfs-kernel-server
    daemon_reload: yes
    state: restarted

## Setup NFS Client Provisioner
- name: Create namespace nfs-storage
  ansible.builtin.command: "kubectl create namespace nfs-storage"
  when: kubeadm_initialized.stat.exists == false

- name: Add helm repo add nfs-subdir-external-provisioner
  ansible.builtin.command: "helm repo add nfs-subdir-external-provisioner https://kubernetes-sigs.github.io/nfs-subdir-external-provisioner/"
  when: kubeadm_initialized.stat.exists == false

- name: helm repo update
  ansible.builtin.command: "helm repo update"
  when: kubeadm_initialized.stat.exists == false

- name: helm install nfs-subdir-external-provisioner nfs-subdir-external-provisioner/nfs-subdir-external-provisioner --set nfs.server={{ ansible_eth1.ipv4.address }} --set nfs.path=/mnt/nfs_share --namespace nfs-storage
  ansible.builtin.command: "helm install nfs-subdir-external-provisioner nfs-subdir-external-provisioner/nfs-subdir-external-provisioner --set nfs.server={{ ansible_eth1.ipv4.address }} --set nfs.path=/mnt/nfs_share --namespace nfs-storage --set storageClass.defaultClass=true"
  when: kubeadm_initialized.stat.exists == false

# # Setup PureLB with helm
# - name: Add helm repo add purelb
#   ansible.builtin.command: "helm repo add purelb https://gitlab.com/api/v4/projects/20400619/packages/helm/stable"
#   when: kubeadm_initialized.stat.exists == false

# - name: helm repo update
#   ansible.builtin.command: "helm repo update"
#   when: kubeadm_initialized.stat.exists == false

# - name: helm install --create-namespace --namespace=purelb purelb purelb/purelb
#   ansible.builtin.command: "helm install --create-namespace --namespace=purelb purelb purelb/purelb"
#   when: kubeadm_initialized.stat.exists == false

# # apiVersion: purelb.io/v1
# # kind: ServiceGroup
# # metadata:
# #   name: default
# #   namespace: purelb
# # spec:
# #   local:
# #     v4pools:
# #     - subnet: '192.168.56.0/24'
# #       pool: '192.168.56.100-192.168.56.200'
# #       aggregation: /25
# - name: Create purelb default pool
#   ansible.builtin.shell: "echo 'apiVersion: purelb.io/v1\nkind: ServiceGroup\nmetadata:\n  name: default\n  namespace: purelb\nspec:\n  local:\n    v4pools:\n    - subnet: \"{{ ansible_eth1.ipv4.network }}/24\"\n      pool: \"{{ ansible_eth1.ipv4.address }}-{{ ansible_eth1.ipv4.address }}\"\n      aggregation: /25' > /home/{{ ansible_user }}/purelb-default-pool.yaml"
#   when: kubeadm_initialized.stat.exists == false

# - name: Create purelb default pool
#   ansible.builtin.command: "kubectl apply -f /home/{{ ansible_user }}/purelb-default-pool.yaml"
#   when: kubeadm_initialized.stat.exists == false

# # Traefik Ingress Controller <<<< not working for now, lets install metalLB first
# - name: Create namespace traefik
#   ansible.builtin.command: "kubectl create namespace traefik-v2"
#   when: kubeadm_initialized.stat.exists == false

# - name: Add helm repo add traefik
#   ansible.builtin.command: "helm repo add traefik https://traefik.github.io/charts"
#   when: kubeadm_initialized.stat.exists == false

# - name: helm repo update
#   ansible.builtin.command: "helm repo update"
#   when: kubeadm_initialized.stat.exists == false

#   ### set ports.traefik.hostIP to {{ ansible_eth1.ipv4.address }}
# - name: helm install traefik traefik/traefik --namespace=traefik-v2 --set ports.traefik.hostIP={{ ansible_eth1.ipv4.address }}

# # NGINX Ingress Controller
# - name: Add helm repo add ingress-nginx
#   ansible.builtin.command: "helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx"
#   when: kubeadm_initialized.stat.exists == false

# - name: helm repo update
#   ansible.builtin.command: "helm repo update"
#   when: kubeadm_initialized.stat.exists == false

# - name: helm install ingress-nginx ingress-nginx/ingress-nginx --set controller.service.externalIPs[0]={{ ansible_eth1.ipv4.address }}
#   ansible.builtin.command: "helm install ingress-nginx ingress-nginx/ingress-nginx --set controller.service.externalIPs[0]={{ ansible_eth1.ipv4.address }}"
#   when: kubeadm_initialized.stat.exists == false



# # Install Prometheus with Helm
# - name: Add helm repo add prometheus-community
#   ansible.builtin.command: "helm repo add prometheus-community https://prometheus-community.github.io/helm-charts"
#   when: kubeadm_initialized.stat.exists == false

# - name: helm repo update
#   ansible.builtin.command: "helm repo update"
#   when: kubeadm_initialized.stat.exists == false

# - name: helm install prometheus prometheus-community/prometheus --set server.persistentVolume.size=1Gi --set alertmanager.persistentVolume.size=1Gi
#   ansible.builtin.command: "helm install prometheus prometheus-community/prometheus --set server.persistentVolume.size=1Gi --set alertmanager.persistentVolume.size=1Gi"
#   when: kubeadm_initialized.stat.exists == false

# - name: Create Ingress for Prometheus
#   ansible.builtin.command: "kubectl apply -f /ansible/playbooks/prometheus/prometheus-ingress.yaml"
#   when: kubeadm_initialized.stat.exists == false

# - name: Update /etc/hosts with prometheus.example.com
#   become: true
#   ansible.builtin.lineinfile:
#     path: /etc/hosts
#     line: "{{ ansible_eth1.ipv4.address }} prometheus.example.com"

# # Install Grafana with Helm
# - name: Add helm repo add grafana
#   ansible.builtin.command: "helm repo add grafana https://grafana.github.io/helm-charts"
#   when: kubeadm_initialized.stat.exists == false

# - name: helm repo update
#   ansible.builtin.command: "helm repo update"
#   when: kubeadm_initialized.stat.exists == false

# - name: Create namespace grafana
#   ansible.builtin.command: "kubectl create namespace grafana"
#   when: kubeadm_initialized.stat.exists == false

# - name: helm install grafana grafana/grafana --set persistence.enabled=true,persistence.size=1Gi --namespace grafana
#   ansible.builtin.command: "helm install grafana grafana/grafana --set persistence.enabled=true,persistence.size=1Gi --namespace grafana"
#   when: kubeadm_initialized.stat.exists == false

# - name: Create Ingress for Grafana
#   ansible.builtin.command: "kubectl apply -f /ansible/playbooks/grafana/grafana-ingress.yaml"
#   when: kubeadm_initialized.stat.exists == false

# - name: Update /etc/hosts with grafana.example.com
#   become: true
#   ansible.builtin.lineinfile:
#     path: /etc/hosts
#     line: "{{ ansible_eth1.ipv4.address }} grafana.example.com"

# # ArgoCD

# - name: Create namespace argocd
#   ansible.builtin.command: "kubectl create namespace argocd"
#   when: kubeadm_initialized.stat.exists == false

# - name: Add helm repo add argo
#   ansible.builtin.command: "helm repo add argo https://argoproj.github.io/argo-helm"
#   when: kubeadm_initialized.stat.exists == false

# - name: helm repo update
#   ansible.builtin.command: "helm repo update"
#   when: kubeadm_initialized.stat.exists == false

# - name: helm install argocd argo/argo-cd --namespace argocd --version 3.12.3 --set server.ingress.enabled=true --set server.ingress.hosts[0]=argocd.example.com --set server.extraArgs={--insecure} --set server.extraEnv[0].name=ARGOCD_OPTS --set server.extraEnv[0].value="--insecure"
#   ansible.builtin.command: "helm install argocd argo/argo-cd --namespace argocd --version 3.12.3 --set server.ingress.enabled=true --set server.ingress.hosts[0]=argocd.example.com --set server.extraArgs={--insecure} --set server.extraEnv[0].name=ARGOCD_OPTS --set server.extraEnv[0].value="--insecure"
#   when: kubeadm_initialized.stat.exists == false

# - name: Update /etc/hosts with argocd.example.com
#   become: true
#   ansible.builtin.lineinfile:
#     path: /etc/hosts
#     line: "{{ ansible_eth1.ipv4.address }} argocd.example.com"

    